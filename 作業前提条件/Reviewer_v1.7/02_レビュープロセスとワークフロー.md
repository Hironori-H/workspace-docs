# レビュープロセスとワークフロー - Reviewer用

## 📌 このモジュールについて

**用途**: ステップバイステップのレビュープロセスの詳細
**必読条件**: レビュー作業中に手順を確認したい時
**関連モジュール**: 00_QUICK_REFERENCE.md（最重要ルール）、03_チェックリストと評価基準.md（詳細なチェックリスト）

---

## レビュープロセス

### ステップ0: Workspace全体の把握（重要）

**最重要**: 個別ファイルのレビュー前に、必ずworkspace全体を把握する。

#### Workspace全体の構造理解

レビューを開始する前に、以下の手順でworkspace全体の状況を把握：

1. **ディレクトリ構造の確認**
   ```
   workspace/
   ├── YYYYMMDD/          # 日付別作業フォルダ
   │   ├── *.py           # Pythonスクリプト
   │   ├── *.bat          # バッチファイル
   │   ├── README.md      # 説明ドキュメント
   │   └── reject_files/  # 却下されたファイル
   ├── DOCS/              # ドキュメント管理フォルダ
   │   ├── 作業前提条件_Worker.md
   │   ├── 作業前提条件_Reviewer.md
   │   └── その他の仕様書・ガイドライン
   └── batch_file/        # 共通バッチファイル
       └── templates/     # テンプレートファイル
   ```

2. **Globツールでworkspace全体を探索**
   - `**/*.py` で全Pythonスクリプトを確認
   - `**/*.bat` で全バッチファイルを確認
   - `**/README.md` で全ドキュメントを確認
   - `**/reject_files/*` で却下されたファイルを確認

3. **DOCSフォルダの最新情報を確認**
   - 作業前提条件_Worker.mdの最新版を確認
   - プロジェクト固有の仕様書を確認
   - 過去のレビュー結果を確認（存在する場合）

4. **関連ファイルの依存関係を把握**
   - Grepツールでimport文を検索し、ファイル間の依存関係を確認
   - バッチファイルから呼び出されるスクリプトを確認
   - 設定ファイル・環境変数の使用状況を確認

5. **日付フォルダの履歴を確認**
   - 過去の日付フォルダと比較し、変更点を把握
   - 同じ機能の過去バージョンがあるか確認
   - reject_filesフォルダ内の却下理由を確認（学習のため）

#### Workspace全体把握のチェックリスト

レビュー前に以下を確認：

- [ ] workspace全体のディレクトリ構造を理解した
- [ ] 今回レビュー対象のフォルダがworkspace内のどこに位置するか把握した
- [ ] DOCSフォルダ内の最新仕様書・ガイドラインを確認した
- [ ] 関連する過去の作業フォルダ（日付フォルダ）を確認した
- [ ] reject_filesフォルダがあれば、却下理由を確認した
- [ ] レビュー対象ファイルが依存している他のファイルを特定した
- [ ] 同じ機能の過去バージョンとの差分を理解した
- [ ] プロジェクト全体のコーディングスタイル・パターンを把握した

#### 全体把握の重要性

**なぜ全体把握が必要か**:

1. **コンテキストの理解**
   - 個別ファイルだけでなく、プロジェクト全体の中での役割を理解
   - 他のファイルとの依存関係・連携を把握

2. **一貫性の確認**
   - プロジェクト全体のコーディングスタイルとの一貫性を評価
   - 既存の実装パターンとの整合性を確認

3. **重複の検出**
   - 既に同じ機能が実装されていないか確認
   - 過去の却下ファイルと同じ問題がないか確認

4. **進化の把握**
   - 過去バージョンからの改善点を理解
   - レビュー基準の一貫性を保つ

5. **効率的なレビュー**
   - 必要な情報を事前に収集
   - レビュー中の行き来を減らす

#### 全体把握の実施例

**良い実施例**:
```
1. Globツールで `20251114/**/*` を検索し、全ファイルをリストアップ
2. Readツールで `20251114/README.md` を読み、作業内容を理解
3. Globツールで `20251113/**/*` を検索し、前日の作業と比較
4. Grepツールで `import|from` を検索し、依存関係を把握
5. Readツールで `DOCS/作業前提条件_Worker.md` を確認
6. 全体像を理解した上で、個別ファイルのレビューを開始
```

**悪い実施例**:
```
1. いきなり `20251114/script.py` を読み始める
2. 他のファイルとの関係を理解せずにレビュー
3. プロジェクトの全体像を把握しないまま評価
4. 結果：的外れな指摘、一貫性のない評価
```

---

### ステップ0.5: ユーザーの事前指示の確認（最重要）

**最重要**: 修正指示書を作成する前に、必ずユーザーの事前指示を確認する。

#### ユーザーの事前指示の確認の重要性

Reviewerが修正指示書を作成する際、Workerはその指示に従って作業を行います。
しかし、**ユーザーが事前に明示した指示がある場合、それが最優先**となります。

Reviewerの修正指示とユーザーの事前指示が矛盾すると、Workerが混乱し、間違った作業を行う可能性があります。

#### 発生した実例

**問題のケース**:
```
【状況】
- ユーザー: 「バージョンは v1.0 のままにしてください」と明示
- Reviewer: 修正指示書で「v1.1 に更新」と指示
- Worker: Reviewerの指示に従い v1.1 に更新（誤り）

【正しい対応】
- Reviewer: ユーザーの「v1.0 維持」指示を確認
- Reviewer: 修正指示書に「バージョンは v1.0 のまま維持（ユーザー指示）」と明記
- Worker: v1.0 のまま作業を実施（正しい）
```

#### 確認すべき事前指示の種類

修正指示書を作成する前に、以下のユーザー指示を確認：

1. **バージョン番号に関する指示**
   - 「v1.0 のまま維持してください」
   - 「完了してから v2.0 にアップデート」
   - 「メジャーバージョンは変更しない」

2. **実装方針に関する指示**
   - 「完全自動化を前提とする」
   - 「既存コードは変更しない」
   - 「Python 3.9 互換性を維持」

3. **ファイル管理に関する指示**
   - 「新規ファイルは作成しない」
   - 「既存ファイルを上書きしない」
   - 「reject_files フォルダには移動しない」

4. **作業範囲に関する指示**
   - 「この機能のみ実装」
   - 「ドキュメントは後で更新」
   - 「テストは別途実施」

5. **技術選択に関する指示**
   - 「特定のライブラリを使用」
   - 「特定のツールを避ける」
   - 「特定のアーキテクチャを採用」

#### 事前指示の確認手順

**ステップ1: 会話履歴を確認**
```
1. ユーザーの過去のメッセージを読み返す
2. 「〜してください」「〜のままで」「〜は変更しない」などの指示を探す
3. 明示的な制約・条件を全てリストアップ
```

**ステップ2: 作業ログを確認**
```
1. YYYYMMDD_worklog.md を確認
2. 「ユーザー指示」「制約」「前提条件」などのセクションを確認
3. 過去のユーザー指示が記録されているか確認
```

**ステップ3: 仕様書・ドキュメントを確認**
```
1. DOCS/ フォルダ内の仕様書を確認
2. 「前提条件」「制約」「要件」などのセクションを確認
3. ユーザーが承認した仕様を確認
```

**ステップ4: 不明な場合はユーザーに確認**
```
【確認すべきケース】
- バージョン番号を変更する場合
- 既存の実装方針を変更する場合
- 大規模なリファクタリングを提案する場合
- ユーザーの意図が不明瞭な場合

【確認の例】
- 「バージョンを v1.1 に更新しても良いですか？」
- 「既存の自動化方針を変更する提案がありますが、問題ありませんか？」
- 「新規ファイルを作成する修正案ですが、よろしいですか？」
```

#### 修正指示書へのユーザー指示の明記

修正指示書を作成する際、必ず以下を含める：

**テンプレート**:
```markdown
# 修正指示書

## ユーザーの事前指示（最優先）

【重要】以下のユーザー指示を厳守してください：

1. **バージョン番号**: v1.0 のまま維持（ユーザー指示: 2025-11-14）
2. **実装方針**: 完全自動化を前提とする（ユーザー指示: 2025-11-14）
3. **ファイル管理**: 既存ファイルのみ編集、新規ファイルは作成しない（ユーザー指示: 2025-11-14）

## 修正内容

【上記のユーザー指示を遵守した上で】以下の修正を実施：

1. ...
2. ...
```

#### 矛盾を発見した場合の対処

**Reviewerの視点で矛盾を発見した場合**:

1. **作業を一旦停止**
   - 修正指示書の作成を中断

2. **AskUserQuestion ツールでユーザーに確認**
   ```
   【確認内容の例】
   - 「レビュー結果として v1.1 への更新が推奨されますが、
      以前『v1.0 のまま』と指示されていました。
      どちらを優先すべきでしょうか？」

   - 「技術的には自動化が可能ですが、
      『手動実行を前提』と指示されていました。
      方針を変更しても良いでしょうか？」
   ```

3. **ユーザーの判断を待つ**
   - 勝手に判断しない
   - 「おそらく〜だろう」と憶測しない

4. **ユーザーの指示に従って修正指示書を作成**
   - ユーザーが優先順位を明確化した後に作業再開

#### チェックリスト: 修正指示書作成前の確認

修正指示書を作成する前に、必ず以下を確認：

- [ ] 会話履歴を読み返し、ユーザーの事前指示をリストアップした
- [ ] 作業ログ（YYYYMMDD_worklog.md）を確認した
- [ ] DOCS/ フォルダ内の仕様書・ドキュメントを確認した
- [ ] バージョン番号に関するユーザー指示を確認した
- [ ] 実装方針に関するユーザー指示を確認した
- [ ] ファイル管理に関するユーザー指示を確認した
- [ ] 作業範囲に関するユーザー指示を確認した
- [ ] 技術選択に関するユーザー指示を確認した
- [ ] 修正指示書にユーザーの事前指示を明記した
- [ ] Reviewerの提案とユーザー指示に矛盾がないか確認した
- [ ] 矛盾がある場合、ユーザーに確認した

#### 正しい対応例と誤った対応例

**正しい対応例**:
```
【シナリオ】
- ユーザー指示: 「v1.0 のままにしてください」（2025-11-14 10:00）
- レビュー結果: いくつかの改善点を発見

【Reviewerの正しい対応】
1. ユーザー指示「v1.0 維持」を確認
2. 修正指示書に以下を明記：

   ## ユーザーの事前指示（最優先）
   - **バージョン番号**: v1.0 のまま維持（ユーザー指示: 2025-11-14）

   ## 修正内容
   【v1.0 のまま】以下の改善を実施：
   - エラーハンドリングを追加
   - ドキュメントを修正

3. Workerはユーザー指示を遵守し、v1.0 のまま改善を実施
```

**誤った対応例**:
```
【シナリオ】
- ユーザー指示: 「v1.0 のままにしてください」（2025-11-14 10:00）
- レビュー結果: いくつかの改善点を発見

【Reviewerの誤った対応】
1. ユーザー指示を確認せず、レビュー結果のみで判断
2. 修正指示書に「v1.1 に更新」と記載
3. Workerは修正指示書に従い v1.1 に更新
4. 結果：ユーザーの指示に反する作業を実施してしまう（誤り）
```

#### 最重要原則（Reviewer用）

1. **ユーザーの事前指示が最優先**
   - Reviewerの技術的判断よりもユーザー指示を優先
   - 「技術的には○○が良い」と思っても、ユーザー指示があれば従う

2. **修正指示書にユーザー指示を必ず明記**
   - Workerがユーザー指示を見落とさないようにする
   - 「ユーザーの事前指示」セクションを必ず追加

3. **矛盾を発見したら、必ずユーザーに確認**
   - 勝手に判断しない
   - 「おそらく○○だろう」という憶測で進めない

4. **バージョン番号の変更は特に注意**
   - ユーザーが明示的に許可していない限り、バージョン番号は変更しない
   - 疑問がある場合は必ずユーザーに確認

---

### ステップ0.6: 修正指示書へのバックアップ手順の明記（必須）

**最重要**: 修正指示書を作成する際、必ずバックアップ手順を含める。

#### バックアップ手順の記載が必要な理由

1. **Workerへの明確な指示**: バックアップのタイミングと方法を明確化
2. **バックアップの一貫性**: すべての修正で確実にバックアップが取られる
3. **作業指示書との紐付け**: バックアップファイル名に作業指示書の要約を含める
4. **復元の容易性**: どの作業指示書で修正されたかが一目で分かる

#### 修正指示書へのバックアップ手順テンプレート

**すべての修正指示書に以下を含めること**:

```markdown
## バックアップ情報

**作業指示書の要約**: [重要なキーワードのみ抽出]

**バックアップファイル名**:
- レベル1（修正前）: `[ファイル名].backup_YYYYMMDD_[要約]_before`
- レベル2（検証済み）: `[ファイル名].backup_YYYYMMDD_[要約]_verified`

**例**:
- レベル1: `SimpleTrigger.jsx.backup_20251119_ダイアログ自動クローズ_before`
- レベル2: `SimpleTrigger.jsx.backup_20251119_ダイアログ自動クローズ_verified`

---

## 実装手順

### ステップ1: バックアップの作成（レベル1: 必須）

**重要**: 修正を開始する前に、必ずバックアップを作成してください。

\`\`\`bash
# [ファイル名] のバックアップ（レベル1: 修正前）
copy "[元のパス]" "[元のパス].backup_YYYYMMDD_[要約]_before"
\`\`\`

**確認事項**:
- [ ] バックアップファイルが作成された
- [ ] ファイルサイズが0でない
- [ ] 作業ログにバックアップファイル名を記録した

### ステップ2: 修正の実施
[修正内容を記載]

### ステップ3: 動作確認
[テスト手順を記載]

### ステップ4: バックアップの作成（レベル2: 検証済み）

**テスト成功後**: 検証済みバックアップを作成してください。

\`\`\`bash
# [ファイル名] のバックアップ（レベル2: 検証済み）
copy "[元のパス]" "[元のパス].backup_YYYYMMDD_[要約]_verified"
\`\`\`

**確認事項**:
- [ ] 動作確認が完了している
- [ ] バックアップファイルが作成された
- [ ] 作業ログにバックアップファイル名を記録した
```
\`\`\`

#### 作業指示書の要約の作り方

修正指示書のファイル名から重要なキーワードのみを抽出：

| 修正指示書ファイル名 | 要約（バックアップに使用） |
|---------------------|--------------------------|
| `20251119_作業指示_AE自動化_ダイアログ自動クローズ機能追加.md` | `ダイアログ自動クローズ` |
| `20251120_修正指示_AE自動化_エラーハンドリング強化.md` | `エラーハンドリング強化` |
| `20251121_作業指示_DB最適化_インデックス追加.md` | `DB最適化_インデックス追加` |

#### 大容量ファイルの確認

**基準**: 1つで数GB以上、または複数で数百MB以上のファイル

**確認が必要な場合のテンプレート**:

```markdown
## バックアップ対象の確認

### 大容量ファイルの確認
- **ファイル**: [ファイル名]（[サイズ]）
- **確認事項**: このファイルをバックアップしますか？
- **ユーザー判断**: [待機中 / 必要 / 不要]
```

**例**:
- データベースダンプファイル（数GB）
- After Effects プロジェクトファイル（.aep）（数百MB）
- 動画ファイル（数GB）

#### バックアップ手順の記載チェックリスト

修正指示書を作成する前に、以下を確認：

- [ ] 「バックアップ情報」セクションを追加した
- [ ] 作業指示書の要約を決定した
- [ ] レベル1バックアップのファイル名を明記した
- [ ] レベル2バックアップのファイル名を明記した
- [ ] 「ステップ1: バックアップの作成（レベル1）」を追加した
- [ ] バックアップコマンドを具体的に記載した
- [ ] 「ステップ4: バックアップの作成（レベル2）」を追加した
- [ ] 大容量ファイルがある場合、ユーザー確認セクションを追加した

---

### ステップ1: 対象の確認

レビュー対象の明確化：

1. **レビュー対象ファイルのリストアップ**
   - Globツールでファイルを検索
   - Workerから提供された情報を確認
   - 変更されたファイルをリストアップ

2. **レビューの範囲を確認**
   - 「全体のレビュー」なのか「特定の機能のみ」なのか
   - 「コードのみ」なのか「ドキュメント含む」なのか
   - 期待される成果物を確認

---

### ステップ2: 詳細レビュー

各ファイルを詳細にレビュー：

1. **ファイルを読む**
   - Readツールで全体を確認
   - 重要な部分を精読
   - コメント・ドキュメントを確認

2. **評価観点でチェック**
   - 機能性、品質、保守性、セキュリティ、パフォーマンス、一貫性
   - チェックリストを使用

3. **問題点を記録**
   - 問題の内容
   - 発生箇所（ファイル名・行番号）
   - 重要度（Critical, Major, Minor, Suggestion）
   - 修正案

---

### ステップ3: フィードバック作成

レビュー結果をまとめる：

**フォーマット例**:

```markdown
# レビュー結果

**レビュー日**: 2025-11-13
**Reviewer**: Claude Code (Reviewer)
**レビュー対象**: 20251113/script.py, 20251113/README.md

---

## 総評

【承認 / 条件付き承認 / 却下】

全体として【評価の概要】。
【主な強み】。
【改善が必要な点】。

---

## 詳細な指摘事項

### Critical（重大）

#### 1. セキュリティ: SQLインジェクションの脆弱性
- **ファイル**: script.py
- **行番号**: 45行目
- **問題**: ユーザー入力を直接SQL文に連結している
- **リスク**: SQLインジェクション攻撃のリスク
- **修正案**: プレースホルダーを使用したパラメータ化クエリに変更

```python
# 現状（危険）
query = f"SELECT * FROM users WHERE id = {user_id}"

# 修正案
query = "SELECT * FROM users WHERE id = ?"
cursor.execute(query, (user_id,))
```

---

### Major（重要）

#### 2. エラーハンドリング: 例外処理の欠如
- **ファイル**: script.py
- **行番号**: 78-85行目
- **問題**: ファイル操作でtry-exceptがない
- **リスク**: ファイルが存在しない場合にクラッシュ
- **修正案**: try-exceptブロックで囲む

---

### Minor（軽微）

#### 3. コーディングスタイル: 変数名の不統一
- **ファイル**: script.py
- **行番号**: 全体
- **問題**: snake_caseとcamelCaseが混在
- **修正案**: PEP 8に従いsnake_caseに統一

---

### Suggestion（提案）

#### 4. 改善提案: ロギングの追加
- **ファイル**: script.py
- **提案内容**: 重要な処理にログ出力を追加すると、デバッグが容易になります
- **実装例**: loggingモジュールを使用

---

## 修正後の再レビュー

上記のCriticalとMajorの指摘を修正後、再度レビューを行います。
Minorは修正推奨ですが、必須ではありません。

---

## その他のコメント

【追加のコメントや提案があれば記載】
```

---

### ステップ4: レビュー結果と修正指示書の作成

**最重要**: レビュー結果と修正指示書は**必ず分離**して作成する。

#### レビュー結果と修正指示書の分離原則

**レビュー結果ドキュメント**と**修正指示書ドキュメント**は、役割と目的が異なるため、必ず別々のファイルとして作成します。

#### レビュー結果ドキュメントの役割

**目的**: テスト・レビューの結果を記録し、評価・判定を行う

**含めるべき内容**:
1. テスト実行結果・環境情報
2. 発見された問題の分析（何が問題か、なぜ問題か）
3. 問題の詳細説明（原因・影響範囲）
4. 修正指示v1の実装状況確認
5. 総合評価（星評価・評価理由）
6. 判定（合格/不合格）
7. テスト計画（修正後の確認項目）
8. 参考情報（ログファイルのパス等）

**含めてはいけない内容**:
- ❌ 具体的な修正コード
- ❌ 修正手順のステップバイステップ説明
- ❌ Workerへの直接的な作業指示

**ファイル名形式**:
```
YYYYMMDD_レビュー結果_[対象]_[機能]_v[番号].md
```

**例**:
- `20251117_レビュー結果_AE自動化_JSON出力改善実装_v1.md`
- `20251114_レビュー結果_バッチファイル_実装_v1.md`

---

#### 修正指示書ドキュメントの役割

**目的**: Workerが作業を実施するための具体的な指示を提供する

**含めるべき内容**:
1. 修正指示サマリー（何を修正するか）
2. 前バージョン（v1, v2...）の実装状況確認
3. 修正内容の詳細説明
4. **具体的な修正コード**（Before/After）
5. **修正手順**（ステップバイステップ）
6. 作業時間見積もり
7. 修正後の確認項目（チェックリスト）
8. テストケース
9. 注意事項
10. 関連ドキュメント

**含めてはいけない内容**:
- ❌ レビューの評価・判定（星評価等）
- ❌ 「良かった点」「問題点」のような評価的記述（実装状況の確認は可）
- ❌ レビュープロセスの記録

**ファイル名形式**:
```
YYYYMMDD_修正指示_[対象]_[機能]_v[番号].md
```

**例**:
- `20251117_修正指示_AE自動化_JSON出力改善_v1.md`（Object.keys, URLエンコード, strokeColor修正）
- `20251117_修正指示_AE自動化_JSON出力改善_v2.md`（boxTextSize修正）

---

#### なぜ分離が必要か

**1. 役割の明確化**
- レビュー結果: 「何が問題か」を分析・評価
- 修正指示書: 「どう修正するか」を具体的に指示

**2. ドキュメントの再利用性**
- 修正指示書は作業完了後も参考資料として保存
- レビュー結果は評価記録として保存

**3. Workerの混乱防止**
- 修正指示書のみを見れば作業内容が明確
- レビュー結果に修正コードが混在すると、何をすべきか不明確

**4. バージョン管理の一貫性**
- 同じ機能の修正は修正指示書のバージョンで管理
- レビュー結果は各テスト実施ごとに作成

---

#### ドキュメント作成の正しいフロー

**ステップ1: テスト・レビュー実施**
```
1. Workerの作業完了を確認
2. テストを実行
3. ログ・出力結果を確認
```

**ステップ2: レビュー結果ドキュメント作成**
```
1. テスト結果を記録
2. 問題点を分析
3. 評価・判定を記載
4. 修正指示書が必要か判断
```

**ステップ3: 修正指示書ドキュメント作成（問題がある場合のみ）**
```
1. 修正が必要な問題をリストアップ
2. 具体的な修正コードを記載
3. 修正手順を記載
4. バージョン番号を決定（v1, v2...）
```

**ステップ4: ドキュメントの相互参照**
```
レビュー結果 → 修正指示書への参照を記載
修正指示書 → レビュー結果への参照を記載
```

---

#### 誤った対応例と正しい対応例

**❌ 誤った対応例**:
```
【シナリオ】
- Workerがv1の修正を実装
- Reviewerがテストを実施し、新たな問題を発見

【誤った対応】
1. レビュー結果ドキュメントに以下を全て記載：
   - テスト結果
   - 問題分析
   - 評価・判定
   - 具体的な修正コード  ← これが混在している
   - 修正手順  ← これも混在している

【問題点】
- ドキュメントの役割が不明確
- Workerが「何を見れば良いか」わからない
- バージョン管理が曖昧
```

**✅ 正しい対応例**:
```
【シナリオ】
- Workerがv1の修正を実装
- Reviewerがテストを実施し、新たな問題を発見

【正しい対応】
1. レビュー結果ドキュメント作成:
   - ファイル名: `20251117_レビュー結果_AE自動化_JSON出力改善実装_v1.md`
   - 内容: テスト結果、問題分析、評価・判定のみ
   - 修正コードは含めない

2. 修正指示書v2ドキュメント作成:
   - ファイル名: `20251117_修正指示_AE自動化_JSON出力改善_v2.md`
   - 内容: v1実装状況、具体的な修正コード、修正手順

3. 相互参照:
   - レビュー結果 → 「修正指示書v2を作成」と記載
   - 修正指示書v2 → 「レビュー結果v1で発見された問題」と記載

【メリット】
- ドキュメントの役割が明確
- Workerは修正指示書v2だけ見れば作業できる
- バージョン管理が明確（v1 → v2の流れがわかる）
```

---

#### ドキュメントのバージョニングルール

**最重要**: 連続した修正内容はバージョン番号で管理する

**バージョニングの基本原則**:

1. **同じ機能の修正は同じファイル名ベースでバージョン番号を上げる**
   ```
   20251117_修正指示_AE自動化_JSON出力改善_v1.md  ← Object.keys, URLエンコード, strokeColor修正
   20251117_修正指示_AE自動化_JSON出力改善_v2.md  ← boxTextSize修正
   20251117_修正指示_AE自動化_JSON出力改善_v3.md  ← さらに追加修正が必要な場合
   ```

2. **新しい独立した機能の修正は新しいファイル名で v1 から開始**
   ```
   20251117_修正指示_AE自動化_JSON出力改善_v1.md     ← JSON出力の改善
   20251117_修正指示_AE自動化_ダイアログ抑制_v1.md   ← 別機能なので v1 から開始
   ```

3. **バージョンアップの判断基準**
   - ✅ v1の修正を実装した結果、新たな問題が発覚 → **v2**
   - ✅ v1の修正が不完全で、追加修正が必要 → **v2**
   - ✅ v1の修正に関連する改善提案 → **v2**
   - ❌ 全く別の機能の修正 → **新しいファイル名で v1**
   - ❌ 別のタイミング・別の目的の修正 → **新しいファイル名で v1**

**バージョンアップの具体例**:

**例1: JSON出力改善の連続修正**
```
【v1】Object.keys, URLエンコード, strokeColor の3つの問題を修正
   ↓ Workerが実装
   ↓ Reviewerがテスト
   ↓ 新たな問題（boxTextSize）を発見
【v2】boxTextSize の問題を修正  ← v1と同じ「JSON出力改善」なので v2
```

**例2: 別機能の修正**
```
【v1】JSON出力改善
【別ファイル v1】ダイアログ抑制機能  ← 全く別機能なので新しいファイル名で v1
```

**バージョン番号の意味**:

| バージョン | 意味 |
|---------|------|
| v1 | 最初の修正指示 |
| v2 | v1の実装後に発見された追加修正 |
| v3 | v2の実装後に発見された追加修正 |
| v4... | さらに追加修正が必要な場合 |

**注意**:
- v1, v2, v3... という番号は「同じ機能の修正の進化」を表す
- 別機能の修正は別ファイルで v1 から開始する

---

#### ファイル名の完全な命名規則

**基本フォーマット**:
```
YYYYMMDD_[ドキュメント種別]_[対象]_[機能]_v[番号].md
```

**ドキュメント種別**:
- `レビュー結果` - テスト・レビューの結果記録
- `修正指示` - Workerへの修正指示
- `作業指示` - 新規作業の指示
- `調査結果` - 調査・分析結果の報告
- `作業記録` - 作業履歴の記録

**対象**:
- プロジェクト名や修正対象の名称
- 例: `AE自動化`, `UE自動化`, `バッチファイル`, `workspace`

**機能**:
- 具体的な機能や修正内容
- 例: `JSON出力改善`, `ダイアログ抑制`, `完全自動化`

**バージョン番号**:
- 同じ機能の連続修正は v1, v2, v3...
- 新しい独立した機能は v1 から開始

**例**:
```
20251117_レビュー結果_AE自動化_JSON出力改善実装_v1.md
20251117_修正指示_AE自動化_JSON出力改善_v1.md
20251117_修正指示_AE自動化_JSON出力改善_v2.md
20251117_調査結果_AE自動化_JSON出力問題分析_v1.md
20251117_作業記録_ファイル名命名規則適用_v1.md
```

---

#### チェックリスト: ドキュメント作成前の確認

レビュー結果・修正指示書を作成する前に、必ず以下を確認：

**レビュー結果ドキュメント作成前**:
- [ ] テスト結果を記録した
- [ ] 問題点を分析した
- [ ] 評価・判定を記載した
- [ ] 具体的な修正コード・手順は含めていない
- [ ] ファイル名が命名規則に従っている
- [ ] 修正指示書への参照を記載した（必要な場合）

**修正指示書ドキュメント作成前**:
- [ ] レビュー結果ドキュメントを先に作成した
- [ ] 修正が必要な問題を明確にした
- [ ] バージョン番号を正しく決定した（v1, v2...）
- [ ] 同じ機能の過去の修正指示書を確認した
- [ ] 具体的な修正コードを記載した
- [ ] 修正手順を記載した
- [ ] ファイル名が命名規則に従っている
- [ ] レビュー結果ドキュメントへの参照を記載した

---

### ステップ5: 判定

最終的な判定を行う：

**承認（Approved）**:
- 全ての要件を満たしている
- 指摘事項なし、またはSuggestionのみ
- そのまま使用可能

**条件付き承認（Conditionally Approved）**:
- Minor以下の指摘がある
- 修正後は再レビュー不要
- 指摘事項を修正すれば使用可能

**却下（Rejected）**:
- CriticalまたはMajorの指摘がある
- 修正後の再レビューが必要
- 現状では使用不可

---

**最終更新日**: 2025年11月17日
**バージョン**: 1.3
**更新内容**: レビュー結果と修正指示書の分離ルール、ドキュメントのバージョニングルールを追加
